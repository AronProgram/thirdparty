<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>MySQL++ Reference Manual</title>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=9"/>
  <meta name="generator" content="Doxygen 1.9.1"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>MySQL++: mysqlpp::String Class Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <link href="doxygen.css" rel="stylesheet" type="text/css">
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
     <tbody>
     <tr style="height: 56px;">
      <td id="projectalign" style="padding-left: 0.5em;">
       <div id="projectname">MySQL++
       &#160;<span id="projectnumber">3.3.0</span>
       </div>
      </td>
     </tr>
     </tbody>
    </table>
    </div>
    <!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>mysqlpp</b></li><li class="navelem"><a class="el" href="classmysqlpp_1_1String.html">String</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmysqlpp_1_1String-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mysqlpp::String Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A std::string work-alike that can convert itself from SQL text data formats to C++ data types.  
 <a href="classmysqlpp_1_1String.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mystring_8h_source.html">mystring.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af2ac840e79adca00ed4f3858ed1e1f75"><td class="memItemLeft" align="right" valign="top"><a id="af2ac840e79adca00ed4f3858ed1e1f75"></a>
typedef const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#af2ac840e79adca00ed4f3858ed1e1f75">value_type</a></td></tr>
<tr class="memdesc:af2ac840e79adca00ed4f3858ed1e1f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the data stored in this object, when it is not equal to SQL null. <br /></td></tr>
<tr class="separator:af2ac840e79adca00ed4f3858ed1e1f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b6729bef9c0a50914a142c361c44b7"><td class="memItemLeft" align="right" valign="top"><a id="af5b6729bef9c0a50914a142c361c44b7"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a></td></tr>
<tr class="memdesc:af5b6729bef9c0a50914a142c361c44b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of "size" integers. <br /></td></tr>
<tr class="separator:af5b6729bef9c0a50914a142c361c44b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c18cd6c1fb2d3130e80b10ff00550e5"><td class="memItemLeft" align="right" valign="top"><a id="a9c18cd6c1fb2d3130e80b10ff00550e5"></a>
typedef const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a9c18cd6c1fb2d3130e80b10ff00550e5">const_iterator</a></td></tr>
<tr class="memdesc:a9c18cd6c1fb2d3130e80b10ff00550e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of iterators. <br /></td></tr>
<tr class="separator:a9c18cd6c1fb2d3130e80b10ff00550e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a55310c5344694df502667a432cc3d"><td class="memItemLeft" align="right" valign="top"><a id="ac9a55310c5344694df502667a432cc3d"></a>
typedef <a class="el" href="classmysqlpp_1_1String.html#a9c18cd6c1fb2d3130e80b10ff00550e5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#ac9a55310c5344694df502667a432cc3d">iterator</a></td></tr>
<tr class="memdesc:ac9a55310c5344694df502667a432cc3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as const_iterator because the data cannot be changed. <br /></td></tr>
<tr class="separator:ac9a55310c5344694df502667a432cc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae711df130eb705131bb4121b58114304"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#ae711df130eb705131bb4121b58114304">String</a> ()</td></tr>
<tr class="memdesc:ae711df130eb705131bb4121b58114304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classmysqlpp_1_1String.html#ae711df130eb705131bb4121b58114304">More...</a><br /></td></tr>
<tr class="separator:ae711df130eb705131bb4121b58114304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e81654babcc5d285b3e9f838833bd88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a7e81654babcc5d285b3e9f838833bd88">String</a> (const <a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;other)</td></tr>
<tr class="memdesc:a7e81654babcc5d285b3e9f838833bd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy ctor.  <a href="classmysqlpp_1_1String.html#a7e81654babcc5d285b3e9f838833bd88">More...</a><br /></td></tr>
<tr class="separator:a7e81654babcc5d285b3e9f838833bd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ff5d5045cbca01c441d2b1b1b02136"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#af5ff5d5045cbca01c441d2b1b1b02136">String</a> (const char *str, <a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a> len, <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> <a class="el" href="classmysqlpp_1_1String.html#af131cc4467ce7db60cb06c037ae07b4c">type</a>=<a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a>, bool <a class="el" href="classmysqlpp_1_1String.html#a79cfd0846cb9c83720d996ec1c601c65">is_null</a>=false)</td></tr>
<tr class="memdesc:af5ff5d5045cbca01c441d2b1b1b02136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full constructor.  <a href="classmysqlpp_1_1String.html#af5ff5d5045cbca01c441d2b1b1b02136">More...</a><br /></td></tr>
<tr class="separator:af5ff5d5045cbca01c441d2b1b1b02136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d39e2ae5aeb13761b80fafcfdcb8a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#af6d39e2ae5aeb13761b80fafcfdcb8a0">String</a> (const std::string &amp;str, <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> <a class="el" href="classmysqlpp_1_1String.html#af131cc4467ce7db60cb06c037ae07b4c">type</a>=<a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a>, bool <a class="el" href="classmysqlpp_1_1String.html#a79cfd0846cb9c83720d996ec1c601c65">is_null</a>=false)</td></tr>
<tr class="memdesc:af6d39e2ae5aeb13761b80fafcfdcb8a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ string version of full ctor.  <a href="classmysqlpp_1_1String.html#af6d39e2ae5aeb13761b80fafcfdcb8a0">More...</a><br /></td></tr>
<tr class="separator:af6d39e2ae5aeb13761b80fafcfdcb8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb546bc0f5231627b93c66746a9cd3c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#afb546bc0f5231627b93c66746a9cd3c0">String</a> (const char *str, <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> <a class="el" href="classmysqlpp_1_1String.html#af131cc4467ce7db60cb06c037ae07b4c">type</a>=<a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a>, bool <a class="el" href="classmysqlpp_1_1String.html#a79cfd0846cb9c83720d996ec1c601c65">is_null</a>=false)</td></tr>
<tr class="memdesc:afb546bc0f5231627b93c66746a9cd3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null-terminated C string version of full ctor.  <a href="classmysqlpp_1_1String.html#afb546bc0f5231627b93c66746a9cd3c0">More...</a><br /></td></tr>
<tr class="separator:afb546bc0f5231627b93c66746a9cd3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e145f153028b0932fe916159f803dc"><td class="memItemLeft" align="right" valign="top"><a id="a43e145f153028b0932fe916159f803dc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a43e145f153028b0932fe916159f803dc">~String</a> ()</td></tr>
<tr class="memdesc:a43e145f153028b0932fe916159f803dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy string. <br /></td></tr>
<tr class="separator:a43e145f153028b0932fe916159f803dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d5fc7add1e11e9f11b8169a7f2c792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a07d5fc7add1e11e9f11b8169a7f2c792">assign</a> (const char *str, <a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a> len, <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> <a class="el" href="classmysqlpp_1_1String.html#af131cc4467ce7db60cb06c037ae07b4c">type</a>=<a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a>, bool <a class="el" href="classmysqlpp_1_1String.html#a79cfd0846cb9c83720d996ec1c601c65">is_null</a>=false)</td></tr>
<tr class="memdesc:a07d5fc7add1e11e9f11b8169a7f2c792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign raw data to this object.  <a href="classmysqlpp_1_1String.html#a07d5fc7add1e11e9f11b8169a7f2c792">More...</a><br /></td></tr>
<tr class="separator:a07d5fc7add1e11e9f11b8169a7f2c792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2495cd58ddbf6427747d8bbfefd4f5b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a2495cd58ddbf6427747d8bbfefd4f5b7">assign</a> (const std::string &amp;str, <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> <a class="el" href="classmysqlpp_1_1String.html#af131cc4467ce7db60cb06c037ae07b4c">type</a>=<a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a>, bool <a class="el" href="classmysqlpp_1_1String.html#a79cfd0846cb9c83720d996ec1c601c65">is_null</a>=false)</td></tr>
<tr class="memdesc:a2495cd58ddbf6427747d8bbfefd4f5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a C++ string to this object.  <a href="classmysqlpp_1_1String.html#a2495cd58ddbf6427747d8bbfefd4f5b7">More...</a><br /></td></tr>
<tr class="separator:a2495cd58ddbf6427747d8bbfefd4f5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30624cfe0e895bb2e20d653c35cca80c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a30624cfe0e895bb2e20d653c35cca80c">assign</a> (const char *str, <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> <a class="el" href="classmysqlpp_1_1String.html#af131cc4467ce7db60cb06c037ae07b4c">type</a>=<a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a>, bool <a class="el" href="classmysqlpp_1_1String.html#a79cfd0846cb9c83720d996ec1c601c65">is_null</a>=false)</td></tr>
<tr class="memdesc:a30624cfe0e895bb2e20d653c35cca80c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a C string to this object.  <a href="classmysqlpp_1_1String.html#a30624cfe0e895bb2e20d653c35cca80c">More...</a><br /></td></tr>
<tr class="separator:a30624cfe0e895bb2e20d653c35cca80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0417324b1aebfc72616ce4d82efc669"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#af0417324b1aebfc72616ce4d82efc669">at</a> (<a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a> pos) const</td></tr>
<tr class="memdesc:af0417324b1aebfc72616ce4d82efc669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a character within the string.  <a href="classmysqlpp_1_1String.html#af0417324b1aebfc72616ce4d82efc669">More...</a><br /></td></tr>
<tr class="separator:af0417324b1aebfc72616ce4d82efc669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8d74d711700dfb13975782d7a54199"><td class="memItemLeft" align="right" valign="top"><a id="abb8d74d711700dfb13975782d7a54199"></a>
<a class="el" href="classmysqlpp_1_1String.html#a9c18cd6c1fb2d3130e80b10ff00550e5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#abb8d74d711700dfb13975782d7a54199">begin</a> () const</td></tr>
<tr class="memdesc:abb8d74d711700dfb13975782d7a54199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator pointing to the first character of the string. <br /></td></tr>
<tr class="separator:abb8d74d711700dfb13975782d7a54199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c26df79f745061a53ed5da9ac409b49"><td class="memItemLeft" align="right" valign="top"><a id="a9c26df79f745061a53ed5da9ac409b49"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a9c26df79f745061a53ed5da9ac409b49">c_str</a> () const</td></tr>
<tr class="memdesc:a9c26df79f745061a53ed5da9ac409b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the string data. <br /></td></tr>
<tr class="separator:a9c26df79f745061a53ed5da9ac409b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e504e60b47e57be9908c1f533f99d0"><td class="memTemplParams" colspan="2"><a id="aa1e504e60b47e57be9908c1f533f99d0"></a>
template&lt;class Type &gt; </td></tr>
<tr class="memitem:aa1e504e60b47e57be9908c1f533f99d0"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#aa1e504e60b47e57be9908c1f533f99d0">conv</a> (Type) const</td></tr>
<tr class="memdesc:aa1e504e60b47e57be9908c1f533f99d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for converting the column data to most any numeric data type. <br /></td></tr>
<tr class="separator:aa1e504e60b47e57be9908c1f533f99d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e78b4e07b6371999898b432b3035cfa"><td class="memTemplParams" colspan="2">template&lt;class T , class B &gt; </td></tr>
<tr class="memitem:a9e78b4e07b6371999898b432b3035cfa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1Null.html">Null</a>&lt; T, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a9e78b4e07b6371999898b432b3035cfa">conv</a> (<a class="el" href="classmysqlpp_1_1Null.html">Null</a>&lt; T, B &gt;) const</td></tr>
<tr class="memdesc:a9e78b4e07b6371999898b432b3035cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <a class="el" href="classmysqlpp_1_1String.html#aa1e504e60b47e57be9908c1f533f99d0" title="Template for converting the column data to most any numeric data type.">conv()</a> for types wrapped with Null&lt;&gt;  <a href="classmysqlpp_1_1String.html#a9e78b4e07b6371999898b432b3035cfa">More...</a><br /></td></tr>
<tr class="separator:a9e78b4e07b6371999898b432b3035cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2143864e43d0feb640f685f91c5f477"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#ac2143864e43d0feb640f685f91c5f477">compare</a> (const <a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;other) const</td></tr>
<tr class="memdesc:ac2143864e43d0feb640f685f91c5f477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexically compare this string to another.  <a href="classmysqlpp_1_1String.html#ac2143864e43d0feb640f685f91c5f477">More...</a><br /></td></tr>
<tr class="separator:ac2143864e43d0feb640f685f91c5f477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0d25c1fd031ad73395e3449896cd40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#ada0d25c1fd031ad73395e3449896cd40">compare</a> (const std::string &amp;other) const</td></tr>
<tr class="memdesc:ada0d25c1fd031ad73395e3449896cd40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexically compare this string to another.  <a href="classmysqlpp_1_1String.html#ada0d25c1fd031ad73395e3449896cd40">More...</a><br /></td></tr>
<tr class="separator:ada0d25c1fd031ad73395e3449896cd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77fd562c855993913006b902b76432d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#ad77fd562c855993913006b902b76432d">compare</a> (<a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a> pos, <a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a> num, std::string &amp;other) const</td></tr>
<tr class="memdesc:ad77fd562c855993913006b902b76432d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexically compare this string to another.  <a href="classmysqlpp_1_1String.html#ad77fd562c855993913006b902b76432d">More...</a><br /></td></tr>
<tr class="separator:ad77fd562c855993913006b902b76432d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcb9d297781a104d74b39475cdce1a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#acbcb9d297781a104d74b39475cdce1a9">compare</a> (const char *other) const</td></tr>
<tr class="memdesc:acbcb9d297781a104d74b39475cdce1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexically compare this string to another.  <a href="classmysqlpp_1_1String.html#acbcb9d297781a104d74b39475cdce1a9">More...</a><br /></td></tr>
<tr class="separator:acbcb9d297781a104d74b39475cdce1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae99b094abc7832f106e6ce121e4595"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#aaae99b094abc7832f106e6ce121e4595">compare</a> (<a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a> pos, <a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a> num, const char *other) const</td></tr>
<tr class="memdesc:aaae99b094abc7832f106e6ce121e4595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexically compare this string to another.  <a href="classmysqlpp_1_1String.html#aaae99b094abc7832f106e6ce121e4595">More...</a><br /></td></tr>
<tr class="separator:aaae99b094abc7832f106e6ce121e4595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778f3f54fd40ec19fc9a800f85f18133"><td class="memItemLeft" align="right" valign="top"><a id="a778f3f54fd40ec19fc9a800f85f18133"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a778f3f54fd40ec19fc9a800f85f18133">data</a> () const</td></tr>
<tr class="memdesc:a778f3f54fd40ec19fc9a800f85f18133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw access to the underlying buffer, with no C string interpretation. <br /></td></tr>
<tr class="separator:a778f3f54fd40ec19fc9a800f85f18133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9159f93d7c73c2a2c5ec62f55db92297"><td class="memItemLeft" align="right" valign="top"><a id="a9159f93d7c73c2a2c5ec62f55db92297"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a9159f93d7c73c2a2c5ec62f55db92297">empty</a> () const</td></tr>
<tr class="memdesc:a9159f93d7c73c2a2c5ec62f55db92297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <a class="el" href="classmysqlpp_1_1String.html#a35ba1053c5e756d26202cbf3c23145b4" title="Return number of bytes in string.">size()</a> == 0. <br /></td></tr>
<tr class="separator:a9159f93d7c73c2a2c5ec62f55db92297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea2346cde37d332327202dbadde9e30"><td class="memItemLeft" align="right" valign="top"><a id="aaea2346cde37d332327202dbadde9e30"></a>
<a class="el" href="classmysqlpp_1_1String.html#a9c18cd6c1fb2d3130e80b10ff00550e5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#aaea2346cde37d332327202dbadde9e30">end</a> () const</td></tr>
<tr class="memdesc:aaea2346cde37d332327202dbadde9e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator pointing to one past the last character of the string. <br /></td></tr>
<tr class="separator:aaea2346cde37d332327202dbadde9e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4275e3e94749bb23896d17c068469917"><td class="memItemLeft" align="right" valign="top"><a id="a4275e3e94749bb23896d17c068469917"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a4275e3e94749bb23896d17c068469917">escape_q</a> () const</td></tr>
<tr class="memdesc:a4275e3e94749bb23896d17c068469917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if data of this type should be escaped, false otherwise. <br /></td></tr>
<tr class="separator:a4275e3e94749bb23896d17c068469917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cfd0846cb9c83720d996ec1c601c65"><td class="memItemLeft" align="right" valign="top"><a id="a79cfd0846cb9c83720d996ec1c601c65"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a79cfd0846cb9c83720d996ec1c601c65">is_null</a> () const</td></tr>
<tr class="memdesc:a79cfd0846cb9c83720d996ec1c601c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this object is a SQL null. <br /></td></tr>
<tr class="separator:a79cfd0846cb9c83720d996ec1c601c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73442369274b0a9425061b8e0cc139f"><td class="memItemLeft" align="right" valign="top"><a id="ac73442369274b0a9425061b8e0cc139f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#ac73442369274b0a9425061b8e0cc139f">it_is_null</a> ()</td></tr>
<tr class="memdesc:ac73442369274b0a9425061b8e0cc139f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmysqlpp_1_1Set.html" title="A special std::set derivative for holding MySQL data sets.">Set</a> a flag indicating that this object is a SQL null. <br /></td></tr>
<tr class="separator:ac73442369274b0a9425061b8e0cc139f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c9621a34af636ec44c7005aacaeee3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a66c9621a34af636ec44c7005aacaeee3">length</a> () const</td></tr>
<tr class="memdesc:a66c9621a34af636ec44c7005aacaeee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of bytes in the string.  <a href="classmysqlpp_1_1String.html#a66c9621a34af636ec44c7005aacaeee3">More...</a><br /></td></tr>
<tr class="separator:a66c9621a34af636ec44c7005aacaeee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e6378c0624036c762bc89f89919edd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a75e6378c0624036c762bc89f89919edd">max_size</a> () const</td></tr>
<tr class="memdesc:a75e6378c0624036c762bc89f89919edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of characters in the string.  <a href="classmysqlpp_1_1String.html#a75e6378c0624036c762bc89f89919edd">More...</a><br /></td></tr>
<tr class="separator:a75e6378c0624036c762bc89f89919edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097ecb7273db07c03ceb190c52e82e54"><td class="memItemLeft" align="right" valign="top"><a id="a097ecb7273db07c03ceb190c52e82e54"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a097ecb7273db07c03ceb190c52e82e54">quote_q</a> () const</td></tr>
<tr class="memdesc:a097ecb7273db07c03ceb190c52e82e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if data of this type should be quoted, false otherwise. <br /></td></tr>
<tr class="separator:a097ecb7273db07c03ceb190c52e82e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ba1053c5e756d26202cbf3c23145b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a35ba1053c5e756d26202cbf3c23145b4">size</a> () const</td></tr>
<tr class="memdesc:a35ba1053c5e756d26202cbf3c23145b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of bytes in string.  <a href="classmysqlpp_1_1String.html#a35ba1053c5e756d26202cbf3c23145b4">More...</a><br /></td></tr>
<tr class="separator:a35ba1053c5e756d26202cbf3c23145b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2d45ea62286c4e491d7d922d66137b"><td class="memItemLeft" align="right" valign="top"><a id="adb2d45ea62286c4e491d7d922d66137b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#adb2d45ea62286c4e491d7d922d66137b">strip_leading_blanks</a> (std::string &amp;s) const</td></tr>
<tr class="memdesc:adb2d45ea62286c4e491d7d922d66137b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of our internal string without leading blanks. <br /></td></tr>
<tr class="separator:adb2d45ea62286c4e491d7d922d66137b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cec60e5c5798929b78c43170167f775"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a5cec60e5c5798929b78c43170167f775">to_string</a> (std::string &amp;s) const</td></tr>
<tr class="memdesc:a5cec60e5c5798929b78c43170167f775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies this object's data into a C++ string.  <a href="classmysqlpp_1_1String.html#a5cec60e5c5798929b78c43170167f775">More...</a><br /></td></tr>
<tr class="separator:a5cec60e5c5798929b78c43170167f775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af131cc4467ce7db60cb06c037ae07b4c"><td class="memItemLeft" align="right" valign="top"><a id="af131cc4467ce7db60cb06c037ae07b4c"></a>
<a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#af131cc4467ce7db60cb06c037ae07b4c">type</a> () const</td></tr>
<tr class="memdesc:af131cc4467ce7db60cb06c037ae07b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this object's current MySQL type. <br /></td></tr>
<tr class="separator:af131cc4467ce7db60cb06c037ae07b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f31d730d66f311a4045bf62b170869d"><td class="memItemLeft" align="right" valign="top"><a id="a6f31d730d66f311a4045bf62b170869d"></a>
<a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a6f31d730d66f311a4045bf62b170869d">operator=</a> (const std::string &amp;rhs)</td></tr>
<tr class="memdesc:a6f31d730d66f311a4045bf62b170869d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator, from C++ string. <br /></td></tr>
<tr class="separator:a6f31d730d66f311a4045bf62b170869d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc9c3f4dd56805e844aba503b175bcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a7bc9c3f4dd56805e844aba503b175bcd">operator=</a> (const char *str)</td></tr>
<tr class="memdesc:a7bc9c3f4dd56805e844aba503b175bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator, from C string.  <a href="classmysqlpp_1_1String.html#a7bc9c3f4dd56805e844aba503b175bcd">More...</a><br /></td></tr>
<tr class="separator:a7bc9c3f4dd56805e844aba503b175bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1252d1e232376f6493755b49761fa439"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a1252d1e232376f6493755b49761fa439">operator=</a> (const <a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;other)</td></tr>
<tr class="memdesc:a1252d1e232376f6493755b49761fa439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator, from other <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types.">String</a>.  <a href="classmysqlpp_1_1String.html#a1252d1e232376f6493755b49761fa439">More...</a><br /></td></tr>
<tr class="separator:a1252d1e232376f6493755b49761fa439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c7fd85e0391a2e3a2864d27ed86929"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a96c7fd85e0391a2e3a2864d27ed86929"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a96c7fd85e0391a2e3a2864d27ed86929">operator==</a> (const T &amp;rhs) const</td></tr>
<tr class="memdesc:a96c7fd85e0391a2e3a2864d27ed86929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator.  <a href="classmysqlpp_1_1String.html#a96c7fd85e0391a2e3a2864d27ed86929">More...</a><br /></td></tr>
<tr class="separator:a96c7fd85e0391a2e3a2864d27ed86929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6cd3a1ea6c7ad6cea716a8eaea9227"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a5e6cd3a1ea6c7ad6cea716a8eaea9227">operator==</a> (const <a class="el" href="classmysqlpp_1_1null__type.html">mysqlpp::null_type</a> &amp;) const</td></tr>
<tr class="memdesc:a5e6cd3a1ea6c7ad6cea716a8eaea9227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator.  <a href="classmysqlpp_1_1String.html#a5e6cd3a1ea6c7ad6cea716a8eaea9227">More...</a><br /></td></tr>
<tr class="separator:a5e6cd3a1ea6c7ad6cea716a8eaea9227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee730cb495dcd5f13208d7c3684dd82"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ee730cb495dcd5f13208d7c3684dd82"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a3ee730cb495dcd5f13208d7c3684dd82">operator!=</a> (const T &amp;rhs) const</td></tr>
<tr class="memdesc:a3ee730cb495dcd5f13208d7c3684dd82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison operator.  <a href="classmysqlpp_1_1String.html#a3ee730cb495dcd5f13208d7c3684dd82">More...</a><br /></td></tr>
<tr class="separator:a3ee730cb495dcd5f13208d7c3684dd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1a97b852f97b37314a2ac17606ba9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a7b1a97b852f97b37314a2ac17606ba9d">operator!=</a> (const <a class="el" href="classmysqlpp_1_1null__type.html">mysqlpp::null_type</a> &amp;) const</td></tr>
<tr class="memdesc:a7b1a97b852f97b37314a2ac17606ba9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison operator.  <a href="classmysqlpp_1_1String.html#a7b1a97b852f97b37314a2ac17606ba9d">More...</a><br /></td></tr>
<tr class="separator:a7b1a97b852f97b37314a2ac17606ba9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf7372054b76c22e33bbdf44b390359"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#aacf7372054b76c22e33bbdf44b390359">operator[]</a> (<a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a> pos) const</td></tr>
<tr class="memdesc:aacf7372054b76c22e33bbdf44b390359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a character within the string.  <a href="classmysqlpp_1_1String.html#aacf7372054b76c22e33bbdf44b390359">More...</a><br /></td></tr>
<tr class="separator:aacf7372054b76c22e33bbdf44b390359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb031ef20e97139a3750f097a9eea7bf"><td class="memItemLeft" align="right" valign="top"><a id="adb031ef20e97139a3750f097a9eea7bf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#adb031ef20e97139a3750f097a9eea7bf">operator const char *</a> () const</td></tr>
<tr class="memdesc:adb031ef20e97139a3750f097a9eea7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const char pointer to the object's raw data. <br /></td></tr>
<tr class="separator:adb031ef20e97139a3750f097a9eea7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fbba4b6b9d85c5cb8667c76cf4cf9a"><td class="memItemLeft" align="right" valign="top"><a id="ab6fbba4b6b9d85c5cb8667c76cf4cf9a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#ab6fbba4b6b9d85c5cb8667c76cf4cf9a">operator signed char</a> () const</td></tr>
<tr class="memdesc:ab6fbba4b6b9d85c5cb8667c76cf4cf9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to a signed char. <br /></td></tr>
<tr class="separator:ab6fbba4b6b9d85c5cb8667c76cf4cf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c21ae0458451ae82e92ed64a7096a9"><td class="memItemLeft" align="right" valign="top"><a id="a82c21ae0458451ae82e92ed64a7096a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a82c21ae0458451ae82e92ed64a7096a9">operator unsigned char</a> () const</td></tr>
<tr class="memdesc:a82c21ae0458451ae82e92ed64a7096a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to an unsigned char. <br /></td></tr>
<tr class="separator:a82c21ae0458451ae82e92ed64a7096a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed67e9a9661a0df677d7037c533c219"><td class="memItemLeft" align="right" valign="top"><a id="a6ed67e9a9661a0df677d7037c533c219"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a6ed67e9a9661a0df677d7037c533c219">operator int</a> () const</td></tr>
<tr class="memdesc:a6ed67e9a9661a0df677d7037c533c219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to an int. <br /></td></tr>
<tr class="separator:a6ed67e9a9661a0df677d7037c533c219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591ed46247129f1393a31350a549b1f9"><td class="memItemLeft" align="right" valign="top"><a id="a591ed46247129f1393a31350a549b1f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a591ed46247129f1393a31350a549b1f9">operator unsigned int</a> () const</td></tr>
<tr class="memdesc:a591ed46247129f1393a31350a549b1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to an unsigned int. <br /></td></tr>
<tr class="separator:a591ed46247129f1393a31350a549b1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362d9ff02feb199298f3329869636ccf"><td class="memItemLeft" align="right" valign="top"><a id="a362d9ff02feb199298f3329869636ccf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a362d9ff02feb199298f3329869636ccf">operator short int</a> () const</td></tr>
<tr class="memdesc:a362d9ff02feb199298f3329869636ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to a short int. <br /></td></tr>
<tr class="separator:a362d9ff02feb199298f3329869636ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c90987f511c39b8a9f1e87c05c608b9"><td class="memItemLeft" align="right" valign="top"><a id="a3c90987f511c39b8a9f1e87c05c608b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a3c90987f511c39b8a9f1e87c05c608b9">operator unsigned short int</a> () const</td></tr>
<tr class="memdesc:a3c90987f511c39b8a9f1e87c05c608b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to an unsigned short int. <br /></td></tr>
<tr class="separator:a3c90987f511c39b8a9f1e87c05c608b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade46267c46a58e55145b9127ea9940f5"><td class="memItemLeft" align="right" valign="top"><a id="ade46267c46a58e55145b9127ea9940f5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#ade46267c46a58e55145b9127ea9940f5">operator long int</a> () const</td></tr>
<tr class="memdesc:ade46267c46a58e55145b9127ea9940f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to a long int. <br /></td></tr>
<tr class="separator:ade46267c46a58e55145b9127ea9940f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e00717ff67a8d61ec15c284ad357567"><td class="memItemLeft" align="right" valign="top"><a id="a9e00717ff67a8d61ec15c284ad357567"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a9e00717ff67a8d61ec15c284ad357567">operator unsigned long int</a> () const</td></tr>
<tr class="memdesc:a9e00717ff67a8d61ec15c284ad357567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to an unsigned long int. <br /></td></tr>
<tr class="separator:a9e00717ff67a8d61ec15c284ad357567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a10dba7e8ca3ff4377e512e38bdcde"><td class="memItemLeft" align="right" valign="top"><a id="a48a10dba7e8ca3ff4377e512e38bdcde"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a48a10dba7e8ca3ff4377e512e38bdcde">operator longlong</a> () const</td></tr>
<tr class="memdesc:a48a10dba7e8ca3ff4377e512e38bdcde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to the platform- specific 'longlong' type, usually a 64-bit integer. <br /></td></tr>
<tr class="separator:a48a10dba7e8ca3ff4377e512e38bdcde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee68e1ba1d6acc1cc19c740ecd8afca4"><td class="memItemLeft" align="right" valign="top"><a id="aee68e1ba1d6acc1cc19c740ecd8afca4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#aee68e1ba1d6acc1cc19c740ecd8afca4">operator ulonglong</a> () const</td></tr>
<tr class="memdesc:aee68e1ba1d6acc1cc19c740ecd8afca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to the platform- specific 'ulonglong' type, usually a 64-bit unsigned integer. <br /></td></tr>
<tr class="separator:aee68e1ba1d6acc1cc19c740ecd8afca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9214795d988addd4ddd7347137f94e6"><td class="memItemLeft" align="right" valign="top"><a id="ac9214795d988addd4ddd7347137f94e6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#ac9214795d988addd4ddd7347137f94e6">operator float</a> () const</td></tr>
<tr class="memdesc:ac9214795d988addd4ddd7347137f94e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to a float. <br /></td></tr>
<tr class="separator:ac9214795d988addd4ddd7347137f94e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e2e69f569cf0a763f3b872a50f028b"><td class="memItemLeft" align="right" valign="top"><a id="a58e2e69f569cf0a763f3b872a50f028b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a58e2e69f569cf0a763f3b872a50f028b">operator double</a> () const</td></tr>
<tr class="memdesc:a58e2e69f569cf0a763f3b872a50f028b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to a double. <br /></td></tr>
<tr class="separator:a58e2e69f569cf0a763f3b872a50f028b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d364d1503a1eb51577c43c4c961ac0"><td class="memItemLeft" align="right" valign="top"><a id="ab0d364d1503a1eb51577c43c4c961ac0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#ab0d364d1503a1eb51577c43c4c961ac0">operator bool</a> () const</td></tr>
<tr class="memdesc:ab0d364d1503a1eb51577c43c4c961ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to a bool. <br /></td></tr>
<tr class="separator:ab0d364d1503a1eb51577c43c4c961ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee36fa5381717ac82bbba1b30f33c002"><td class="memItemLeft" align="right" valign="top"><a id="aee36fa5381717ac82bbba1b30f33c002"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#aee36fa5381717ac82bbba1b30f33c002">operator Date</a> () const</td></tr>
<tr class="memdesc:aee36fa5381717ac82bbba1b30f33c002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to a <a class="el" href="classmysqlpp_1_1Date.html" title="C++ form of SQL&#39;s DATE type.">mysqlpp::Date</a>. <br /></td></tr>
<tr class="separator:aee36fa5381717ac82bbba1b30f33c002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80a17fa4d2125b83a91d180b9c86581"><td class="memItemLeft" align="right" valign="top"><a id="aa80a17fa4d2125b83a91d180b9c86581"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#aa80a17fa4d2125b83a91d180b9c86581">operator DateTime</a> () const</td></tr>
<tr class="memdesc:aa80a17fa4d2125b83a91d180b9c86581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to a <a class="el" href="classmysqlpp_1_1DateTime.html" title="C++ form of SQL&#39;s DATETIME type.">mysqlpp::DateTime</a>. <br /></td></tr>
<tr class="separator:aa80a17fa4d2125b83a91d180b9c86581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3904e41b9760abc26d0d93261747ee6f"><td class="memItemLeft" align="right" valign="top"><a id="a3904e41b9760abc26d0d93261747ee6f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a3904e41b9760abc26d0d93261747ee6f">operator Time</a> () const</td></tr>
<tr class="memdesc:a3904e41b9760abc26d0d93261747ee6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object's string data to a <a class="el" href="classmysqlpp_1_1Time.html" title="C++ form of SQL&#39;s TIME type.">mysqlpp::Time</a>. <br /></td></tr>
<tr class="separator:a3904e41b9760abc26d0d93261747ee6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4916487ca99be70ca919c067a0d4bd1d"><td class="memTemplParams" colspan="2">template&lt;class T , class B &gt; </td></tr>
<tr class="memitem:a4916487ca99be70ca919c067a0d4bd1d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#a4916487ca99be70ca919c067a0d4bd1d">operator Null&lt; T, B &gt;</a> () const</td></tr>
<tr class="memdesc:a4916487ca99be70ca919c067a0d4bd1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types.">String</a> to a nullable data type.  <a href="classmysqlpp_1_1String.html#a4916487ca99be70ca919c067a0d4bd1d">More...</a><br /></td></tr>
<tr class="separator:a4916487ca99be70ca919c067a0d4bd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a970c115220fc891e05eef4cc92705457"><td class="memItemLeft" align="right" valign="top"><a id="a970c115220fc891e05eef4cc92705457"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SQLTypeAdapter</b></td></tr>
<tr class="separator:a970c115220fc891e05eef4cc92705457"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A std::string work-alike that can convert itself from SQL text data formats to C++ data types. </p>
<p>This class is an intermediate form for a SQL field, normally converted to a more useful native C++ type, not used directly. The only exception is in dealing with BLOB data, which stays in <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types.">String</a> form for efficiency and to avoid corrupting the data with facile conversions. Even then, it's best to use it through the typedef aliases like sql_blob in <a class="el" href="sql__types_8h.html" title="Declares the closest C++ equivalent of each MySQL column type.">sql_types.h</a>, in case we later change this underlying representation.</p>
<p><a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types.">String</a>'s implicit conversion operators let you can use these objects naturally:</p>
<div class="fragment"><div class="line"><a class="code" href="classmysqlpp_1_1String.html#ae711df130eb705131bb4121b58114304">String</a>(<span class="stringliteral">&quot;12.86&quot;</span>) + 2.0 </div>
<div class="ttc" id="aclassmysqlpp_1_1String_html_ae711df130eb705131bb4121b58114304"><div class="ttname"><a href="classmysqlpp_1_1String.html#ae711df130eb705131bb4121b58114304">mysqlpp::String::String</a></div><div class="ttdeci">String()</div><div class="ttdoc">Default constructor.</div><div class="ttdef"><b>Definition:</b> mystring.h:167</div></div>
</div><!-- fragment --><p>That will give you 14.86 (approximately) as you expect, but be careful not to get tripped up by C++'s type conversion rules. If you had said this instead:</p>
<div class="fragment"><div class="line"><a class="code" href="classmysqlpp_1_1String.html#ae711df130eb705131bb4121b58114304">String</a>(<span class="stringliteral">&quot;12.86&quot;</span>) + 2 </div>
</div><!-- fragment --><p>the result would be 14 because 2 is an integer, and C++'s type conversion rules put the <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types.">String</a> object in an integer context.</p>
<p>You can disable the operator overloads that allow these things by defining MYSQLPP_NO_BINARY_OPERS.</p>
<p>This class also has some basic information about the type of data stored in it, to allow it to do the conversions more intelligently than a trivial implementation would allow. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae711df130eb705131bb4121b58114304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae711df130eb705131bb4121b58114304">&#9670;&nbsp;</a></span>String() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::String::String </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>An object constructed this way is essentially useless, but sometimes you just need to construct a default object. </p>

</div>
</div>
<a id="a7e81654babcc5d285b3e9f838833bd88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e81654babcc5d285b3e9f838833bd88">&#9670;&nbsp;</a></span>String() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::String::String </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy ctor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types.">String</a> object</td></tr>
  </table>
  </dd>
</dl>
<p>This ctor only copies the pointer to the other <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types.">String</a>'s data buffer and increments its reference counter. If you need a deep copy, use one of the ctors that takes a string. </p>

</div>
</div>
<a id="af5ff5d5045cbca01c441d2b1b1b02136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ff5d5045cbca01c441d2b1b1b02136">&#9670;&nbsp;</a></span>String() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::String::String </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_null</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Full constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string this object represents, or 0 for SQL null </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string; embedded nulls are legal </td></tr>
    <tr><td class="paramname">type</td><td>MySQL type information for data within str </td></tr>
    <tr><td class="paramname">is_null</td><td>string represents a SQL null, not literal data</td></tr>
  </table>
  </dd>
</dl>
<p>The resulting object will contain a copy of the string buffer. The buffer will actually be 1 byte longer than the value given for <code>len</code>, to hold a null terminator for safety. We do this because this ctor may be used for things other than null-terminated C strings. (e.g. BLOB data) </p>

</div>
</div>
<a id="af6d39e2ae5aeb13761b80fafcfdcb8a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d39e2ae5aeb13761b80fafcfdcb8a0">&#9670;&nbsp;</a></span>String() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::String::String </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_null</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++ string version of full ctor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string this object represents, or 0 for SQL null </td></tr>
    <tr><td class="paramname">type</td><td>MySQL type information for data within str </td></tr>
    <tr><td class="paramname">is_null</td><td>string represents a SQL null, not literal data</td></tr>
  </table>
  </dd>
</dl>
<p>The resulting object will contain a copy of the string buffer. </p>

</div>
</div>
<a id="afb546bc0f5231627b93c66746a9cd3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb546bc0f5231627b93c66746a9cd3c0">&#9670;&nbsp;</a></span>String() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::String::String </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_null</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Null-terminated C string version of full ctor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string this object represents, or 0 for SQL null </td></tr>
    <tr><td class="paramname">type</td><td>MySQL type information for data within str </td></tr>
    <tr><td class="paramname">is_null</td><td>string represents a SQL null, not literal data</td></tr>
  </table>
  </dd>
</dl>
<p>The resulting object will contain a copy of the string buffer. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a30624cfe0e895bb2e20d653c35cca80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30624cfe0e895bb2e20d653c35cca80c">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::String::assign </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_null</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a C string to this object. </p>
<p>This parallels the ctor with the same parameters, for when you must do a 2-step create, or when you want to reassign the data without creating a <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types.">String</a> temporary to get around the fact that <a class="el" href="classmysqlpp_1_1String.html#a6f31d730d66f311a4045bf62b170869d" title="Assignment operator, from C++ string.">operator=()</a> can only take one parameter. </p>

</div>
</div>
<a id="a07d5fc7add1e11e9f11b8169a7f2c792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d5fc7add1e11e9f11b8169a7f2c792">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::String::assign </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_null</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign raw data to this object. </p>
<p>This parallels the ctor with the same parameters, for when you must do a 2-step create, or when you want to reassign the data without creating a <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types.">String</a> temporary to get around the fact that <a class="el" href="classmysqlpp_1_1String.html#a6f31d730d66f311a4045bf62b170869d" title="Assignment operator, from C++ string.">operator=()</a> can only take one parameter. </p>

</div>
</div>
<a id="a2495cd58ddbf6427747d8bbfefd4f5b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2495cd58ddbf6427747d8bbfefd4f5b7">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::String::assign </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_null</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a C++ string to this object. </p>
<p>This parallels the ctor with the same parameters, for when you must do a 2-step create, or when you want to reassign the data without creating a <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types.">String</a> temporary to get around the fact that <a class="el" href="classmysqlpp_1_1String.html#a6f31d730d66f311a4045bf62b170869d" title="Assignment operator, from C++ string.">operator=()</a> can only take one parameter. </p>

</div>
</div>
<a id="af0417324b1aebfc72616ce4d82efc669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0417324b1aebfc72616ce4d82efc669">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char mysqlpp::String::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a character within the string. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmysqlpp_1_1BadIndex.html" title="Exception thrown when an object with operator [] or an at() method gets called with a bad index.">mysqlpp::BadIndex</a></td><td>if the row is not initialized or there are less than <code>i</code> fields in the row. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classmysqlpp_1_1SQLBuffer.html#abae32d826be7605448f5480d06974a75">mysqlpp::SQLBuffer::data()</a>, and <a class="el" href="classmysqlpp_1_1String.html#a35ba1053c5e756d26202cbf3c23145b4">size()</a>.</p>

</div>
</div>
<a id="acbcb9d297781a104d74b39475cdce1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbcb9d297781a104d74b39475cdce1a9">&#9670;&nbsp;</a></span>compare() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mysqlpp::String::compare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lexically compare this string to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>string to compare against this one</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>compare(size_type, size_type, const char*) </dd></dl>

<p class="reference">References <a class="el" href="classmysqlpp_1_1String.html#ac2143864e43d0feb640f685f91c5f477">compare()</a>, and <a class="el" href="classmysqlpp_1_1String.html#a66c9621a34af636ec44c7005aacaeee3">length()</a>.</p>

</div>
</div>
<a id="ada0d25c1fd031ad73395e3449896cd40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0d25c1fd031ad73395e3449896cd40">&#9670;&nbsp;</a></span>compare() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mysqlpp::String::compare </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lexically compare this string to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>string to compare against this one</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>compare(size_type, size_type, const char*) </dd></dl>

<p class="reference">References <a class="el" href="classmysqlpp_1_1String.html#ac2143864e43d0feb640f685f91c5f477">compare()</a>, and <a class="el" href="classmysqlpp_1_1String.html#a66c9621a34af636ec44c7005aacaeee3">length()</a>.</p>

</div>
</div>
<a id="ac2143864e43d0feb640f685f91c5f477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2143864e43d0feb640f685f91c5f477">&#9670;&nbsp;</a></span>compare() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mysqlpp::String::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lexically compare this string to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>string to compare against this one</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>compare(size_type, size_type, const char*) </dd></dl>

<p class="reference">References <a class="el" href="classmysqlpp_1_1SQLBuffer.html#abae32d826be7605448f5480d06974a75">mysqlpp::SQLBuffer::data()</a>, and <a class="el" href="classmysqlpp_1_1String.html#a66c9621a34af636ec44c7005aacaeee3">length()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classmysqlpp_1_1String.html#ada0d25c1fd031ad73395e3449896cd40">compare()</a>.</p>

</div>
</div>
<a id="aaae99b094abc7832f106e6ce121e4595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae99b094abc7832f106e6ce121e4595">&#9670;&nbsp;</a></span>compare() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mysqlpp::String::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lexically compare this string to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position within this string to begin comparison </td></tr>
    <tr><td class="paramname">num</td><td>maximum number of characters within this string to use in comparison </td></tr>
    <tr><td class="paramname">other</td><td>string to compare against this one</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;</td><td>0 if this string is lexically "less than" other </td></tr>
    <tr><td class="paramname">0</td><td>if this string is equal to other </td></tr>
    <tr><td class="paramname">&gt;</td><td>0 if this string is lexically "greater than" other </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classmysqlpp_1_1String.html#a778f3f54fd40ec19fc9a800f85f18133">data()</a>, and <a class="el" href="classmysqlpp_1_1String.html#a66c9621a34af636ec44c7005aacaeee3">length()</a>.</p>

</div>
</div>
<a id="ad77fd562c855993913006b902b76432d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77fd562c855993913006b902b76432d">&#9670;&nbsp;</a></span>compare() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mysqlpp::String::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lexically compare this string to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position within this string to begin comparison </td></tr>
    <tr><td class="paramname">num</td><td>maximum number of characters within this string to use in comparison </td></tr>
    <tr><td class="paramname">other</td><td>string to compare against this one</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>compare(size_type, size_type, const char*) </dd></dl>

<p class="reference">References <a class="el" href="classmysqlpp_1_1String.html#ac2143864e43d0feb640f685f91c5f477">compare()</a>.</p>

</div>
</div>
<a id="a9e78b4e07b6371999898b432b3035cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e78b4e07b6371999898b432b3035cfa">&#9670;&nbsp;</a></span>conv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Null.html">Null</a>&lt;T, B&gt; mysqlpp::String::conv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1Null.html">Null</a>&lt; T, B &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of <a class="el" href="classmysqlpp_1_1String.html#aa1e504e60b47e57be9908c1f533f99d0" title="Template for converting the column data to most any numeric data type.">conv()</a> for types wrapped with Null&lt;&gt; </p>
<p>If the <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types.">String</a> object was initialized with some string we recognize as a SQL null, we just return a copy of the global 'null' object converted to the requested type. Otherwise, we return the <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types.">String</a>'s value wrapped in the Null&lt;&gt; template. </p>

</div>
</div>
<a id="a66c9621a34af636ec44c7005aacaeee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c9621a34af636ec44c7005aacaeee3">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">String::size_type</a> mysqlpp::String::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of bytes in the string. </p>
<p>Note that this doesn't count the number of <b>characters</b> in the string. If your database is configured to use an 8-bit character set, this is a distinction without a difference. But, if you're using UTF-8 in the database, you will need to "widen" the UTF-8 data to use a fixed-size character set like UCS-2 and count the characters that way. You might use std::wstring, for example. </p>

<p class="reference">References <a class="el" href="classmysqlpp_1_1SQLBuffer.html#a559e04e15eb087d2519dc3316584bae7">mysqlpp::SQLBuffer::length()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classmysqlpp_1_1String.html#ac2143864e43d0feb640f685f91c5f477">compare()</a>.</p>

</div>
</div>
<a id="a75e6378c0624036c762bc89f89919edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e6378c0624036c762bc89f89919edd">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a> mysqlpp::String::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum number of characters in the string. </p>
<p>Because this is a <code>const</code> string, this is just an alias for <a class="el" href="classmysqlpp_1_1String.html#a35ba1053c5e756d26202cbf3c23145b4" title="Return number of bytes in string.">size()</a>; its size is always equal to the amount of data currently stored. </p>

</div>
</div>
<a id="a4916487ca99be70ca919c067a0d4bd1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4916487ca99be70ca919c067a0d4bd1d">&#9670;&nbsp;</a></span>operator Null&lt; T, B &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::String::operator <a class="el" href="classmysqlpp_1_1Null.html">Null</a>&lt; T, B &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types.">String</a> to a nullable data type. </p>
<p>This is just an implicit version of conv(Null&lt;T, B&gt;) </p>

</div>
</div>
<a id="a7b1a97b852f97b37314a2ac17606ba9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1a97b852f97b37314a2ac17606ba9d">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::String::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1null__type.html">mysqlpp::null_type</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison operator. </p>
<p>For checking object against MySQL++'s global <code>null</code> constant </p>

</div>
</div>
<a id="a3ee730cb495dcd5f13208d7c3684dd82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee730cb495dcd5f13208d7c3684dd82">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::String::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison operator. </p>
<p>For comparing this object to any of the data types we have a <a class="el" href="classmysqlpp_1_1String.html#ac2143864e43d0feb640f685f91c5f477" title="Lexically compare this string to another.">compare()</a> overload for. </p>

</div>
</div>
<a id="a7bc9c3f4dd56805e844aba503b175bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bc9c3f4dd56805e844aba503b175bcd">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1String.html">String</a>&amp; mysqlpp::String::operator= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator, from C string. </p>
<p>This creates a copy of the entire string, not just a copy of the pointer. </p>

<p class="reference">References <a class="el" href="classmysqlpp_1_1mysql__type__info.html#a18d778e786cf06f63a7222129feed227">mysqlpp::mysql_type_info::string_type</a>.</p>

</div>
</div>
<a id="a1252d1e232376f6493755b49761fa439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1252d1e232376f6493755b49761fa439">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1String.html">String</a>&amp; mysqlpp::String::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator, from other <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types.">String</a>. </p>
<p>This only copies the pointer to the other <a class="el" href="classmysqlpp_1_1String.html" title="A std::string work-alike that can convert itself from SQL text data formats to C++ data types.">String</a>'s data buffer and increments its reference counter. If you need a deep copy, assign a string to this object instead. </p>

</div>
</div>
<a id="a5e6cd3a1ea6c7ad6cea716a8eaea9227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6cd3a1ea6c7ad6cea716a8eaea9227">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::String::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1null__type.html">mysqlpp::null_type</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator. </p>
<p>For checking object against MySQL++'s global <code>null</code> constant </p>

</div>
</div>
<a id="a96c7fd85e0391a2e3a2864d27ed86929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c7fd85e0391a2e3a2864d27ed86929">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::String::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator. </p>
<p>For comparing this object to any of the data types we have a <a class="el" href="classmysqlpp_1_1String.html#ac2143864e43d0feb640f685f91c5f477" title="Lexically compare this string to another.">compare()</a> overload for. </p>

</div>
</div>
<a id="aacf7372054b76c22e33bbdf44b390359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf7372054b76c22e33bbdf44b390359">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char mysqlpp::String::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a character within the string. </p>
<p>This function is just syntactic sugar, wrapping the <a class="el" href="classmysqlpp_1_1String.html#af0417324b1aebfc72616ce4d82efc669" title="Return a character within the string.">at()</a> method.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmysqlpp_1_1BadIndex.html" title="Exception thrown when an object with operator [] or an at() method gets called with a bad index.">mysqlpp::BadIndex</a></td><td>if the string is not initialized or there are less than <code>i</code> fields in the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35ba1053c5e756d26202cbf3c23145b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ba1053c5e756d26202cbf3c23145b4">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1String.html#af5b6729bef9c0a50914a142c361c44b7">size_type</a> mysqlpp::String::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of bytes in string. </p>
<p>See commentary for <a class="el" href="classmysqlpp_1_1String.html#a66c9621a34af636ec44c7005aacaeee3" title="Return number of bytes in the string.">length()</a> about the difference between bytes and characters. </p>

<p class="reference">Referenced by <a class="el" href="classmysqlpp_1_1String.html#af0417324b1aebfc72616ce4d82efc669">at()</a>.</p>

</div>
</div>
<a id="a5cec60e5c5798929b78c43170167f775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cec60e5c5798929b78c43170167f775">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::String::to_string </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies this object's data into a C++ string. </p>
<p>If you know the data doesn't contain null characters (i.e. it's a typical string, not BLOB data), it's more efficient to just assign this object to anything taking <code>const</code> <code>char*</code>. (Or equivalently, call the <code><a class="el" href="classmysqlpp_1_1String.html#a778f3f54fd40ec19fc9a800f85f18133" title="Raw access to the underlying buffer, with no C string interpretation.">data()</a></code> method.) This copies a pointer to a buffer instead of copying the buffer's contents. </p>

<p class="reference">References <a class="el" href="classmysqlpp_1_1SQLBuffer.html#abae32d826be7605448f5480d06974a75">mysqlpp::SQLBuffer::data()</a>, and <a class="el" href="classmysqlpp_1_1SQLBuffer.html#a559e04e15eb087d2519dc3316584bae7">mysqlpp::SQLBuffer::length()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="mystring_8h_source.html">mystring.h</a></li>
<li>mystring.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 28 2021 16:40:16 for MySQL++ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
