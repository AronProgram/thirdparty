<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>MySQL++ Reference Manual</title>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=9"/>
  <meta name="generator" content="Doxygen 1.9.1"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>MySQL++: vallist.h File Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <link href="doxygen.css" rel="stylesheet" type="text/css">
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
     <tbody>
     <tr style="height: 56px;">
      <td id="projectalign" style="padding-left: 0.5em;">
       <div id="projectname">MySQL++
       &#160;<span id="projectnumber">3.3.0</span>
       </div>
      </td>
     </tr>
     </tbody>
    </table>
    </div>
    <!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vallist.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Declares templates for holding lists of values.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="manip_8h_source.html">manip.h</a>&quot;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div>
<p><a href="vallist_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmysqlpp_1_1equal__list__ba.html">mysqlpp::equal_list_ba&lt; Seq1, Seq2, Manip &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds two lists of items, typically used to construct a SQL "equals clause".  <a href="structmysqlpp_1_1equal__list__ba.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmysqlpp_1_1equal__list__b.html">mysqlpp::equal_list_b&lt; Seq1, Seq2, Manip &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="structmysqlpp_1_1equal__list__ba.html" title="Holds two lists of items, typically used to construct a SQL &quot;equals clause&quot;.">equal_list_ba</a>, plus the option to have some elements of the equals clause suppressed.  <a href="structmysqlpp_1_1equal__list__b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmysqlpp_1_1value__list__ba.html">mysqlpp::value_list_ba&lt; Seq, Manip &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a list of items, typically used to construct a SQL "value list".  <a href="structmysqlpp_1_1value__list__ba.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmysqlpp_1_1value__list__b.html">mysqlpp::value_list_b&lt; Seq, Manip &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="structmysqlpp_1_1value__list__ba.html" title="Holds a list of items, typically used to construct a SQL &quot;value list&quot;.">value_list_ba</a>, plus the option to have some elements of the list suppressed.  <a href="structmysqlpp_1_1value__list__b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a14959a9a7adf3bdb1f68ab7ea4e6bb7e"><td class="memTemplParams" colspan="2">template&lt;class Seq1 , class Seq2 , class Manip &gt; </td></tr>
<tr class="memitem:a14959a9a7adf3bdb1f68ab7ea4e6bb7e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vallist_8h.html#a14959a9a7adf3bdb1f68ab7ea4e6bb7e">mysqlpp::operator&lt;&lt;</a> (std::ostream &amp;o, const equal_list_ba&lt; Seq1, Seq2, Manip &gt; &amp;el)</td></tr>
<tr class="memdesc:a14959a9a7adf3bdb1f68ab7ea4e6bb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an <a class="el" href="structmysqlpp_1_1equal__list__ba.html" title="Holds two lists of items, typically used to construct a SQL &quot;equals clause&quot;.">equal_list_ba</a> into an std::ostream.  <a href="vallist_8h.html#a14959a9a7adf3bdb1f68ab7ea4e6bb7e">More...</a><br /></td></tr>
<tr class="separator:a14959a9a7adf3bdb1f68ab7ea4e6bb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa2009cde5ff7ee5d817d9e8e1b9ace"><td class="memTemplParams" colspan="2">template&lt;class Seq1 , class Seq2 , class Manip &gt; </td></tr>
<tr class="memitem:a3fa2009cde5ff7ee5d817d9e8e1b9ace"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vallist_8h.html#a3fa2009cde5ff7ee5d817d9e8e1b9ace">mysqlpp::operator&lt;&lt;</a> (std::ostream &amp;o, const equal_list_b&lt; Seq1, Seq2, Manip &gt; &amp;el)</td></tr>
<tr class="memdesc:a3fa2009cde5ff7ee5d817d9e8e1b9ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as operator&lt;&lt; for <a class="el" href="structmysqlpp_1_1equal__list__ba.html" title="Holds two lists of items, typically used to construct a SQL &quot;equals clause&quot;.">equal_list_ba</a>, plus the option to suppress insertion of some list items in the stream.  <a href="vallist_8h.html#a3fa2009cde5ff7ee5d817d9e8e1b9ace">More...</a><br /></td></tr>
<tr class="separator:a3fa2009cde5ff7ee5d817d9e8e1b9ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5190aab5cca65dbb641e287de9cb6f66"><td class="memTemplParams" colspan="2">template&lt;class Seq , class Manip &gt; </td></tr>
<tr class="memitem:a5190aab5cca65dbb641e287de9cb6f66"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vallist_8h.html#a5190aab5cca65dbb641e287de9cb6f66">mysqlpp::operator&lt;&lt;</a> (std::ostream &amp;o, const value_list_ba&lt; Seq, Manip &gt; &amp;cl)</td></tr>
<tr class="memdesc:a5190aab5cca65dbb641e287de9cb6f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a <a class="el" href="structmysqlpp_1_1value__list__ba.html" title="Holds a list of items, typically used to construct a SQL &quot;value list&quot;.">value_list_ba</a> into an std::ostream.  <a href="vallist_8h.html#a5190aab5cca65dbb641e287de9cb6f66">More...</a><br /></td></tr>
<tr class="separator:a5190aab5cca65dbb641e287de9cb6f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42f3fce3eb51f9257d519728ebb247c"><td class="memTemplParams" colspan="2">template&lt;class Seq , class Manip &gt; </td></tr>
<tr class="memitem:ae42f3fce3eb51f9257d519728ebb247c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vallist_8h.html#ae42f3fce3eb51f9257d519728ebb247c">mysqlpp::operator&lt;&lt;</a> (std::ostream &amp;o, const value_list_b&lt; Seq, Manip &gt; &amp;cl)</td></tr>
<tr class="memdesc:ae42f3fce3eb51f9257d519728ebb247c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as operator&lt;&lt; for <a class="el" href="structmysqlpp_1_1value__list__ba.html" title="Holds a list of items, typically used to construct a SQL &quot;value list&quot;.">value_list_ba</a>, plus the option to suppress insertion of some list items in the stream.  <a href="vallist_8h.html#ae42f3fce3eb51f9257d519728ebb247c">More...</a><br /></td></tr>
<tr class="separator:ae42f3fce3eb51f9257d519728ebb247c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99971e8fc60ea71827e96dedee6f12c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>mysqlpp::create_vector</b> (size_t size, std::vector&lt; bool &gt; &amp;v, bool t0, bool t1=false, bool t2=false, bool t3=false, bool t4=false, bool t5=false, bool t6=false, bool t7=false, bool t8=false, bool t9=false, bool ta=false, bool tb=false, bool tc=false)</td></tr>
<tr class="memdesc:af99971e8fc60ea71827e96dedee6f12c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a vector of bool with the given arguments as values.  <a href="vallist_8cpp.html#af99971e8fc60ea71827e96dedee6f12c">More...</a><br /></td></tr>
<tr class="separator:af99971e8fc60ea71827e96dedee6f12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8a0af0d14a6d66b2dd8faca38808fb"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a7c8a0af0d14a6d66b2dd8faca38808fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mysqlpp::create_vector</b> (const Container &amp;c, std::vector&lt; bool &gt; &amp;v, std::string s0, std::string s1, std::string s2, std::string s3, std::string s4, std::string s5, std::string s6, std::string s7, std::string s8, std::string s9, std::string sa, std::string sb, std::string sc)</td></tr>
<tr class="memdesc:a7c8a0af0d14a6d66b2dd8faca38808fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a vector of bool using a list of named fields.  <a href="vallist_8cpp.html#a7c8a0af0d14a6d66b2dd8faca38808fb">More...</a><br /></td></tr>
<tr class="separator:a7c8a0af0d14a6d66b2dd8faca38808fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a72c65d3b93039ff475fa8ccfdefac"><td class="memTemplParams" colspan="2">template&lt;class Seq &gt; </td></tr>
<tr class="memitem:af4a72c65d3b93039ff475fa8ccfdefac"><td class="memTemplItemLeft" align="right" valign="top">value_list_ba&lt; Seq, do_nothing_type0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vallist_8h.html#af4a72c65d3b93039ff475fa8ccfdefac">mysqlpp::value_list</a> (const Seq &amp;s, const char *d=&quot;,&quot;)</td></tr>
<tr class="memdesc:af4a72c65d3b93039ff475fa8ccfdefac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="structmysqlpp_1_1value__list__ba.html" title="Holds a list of items, typically used to construct a SQL &quot;value list&quot;.">value_list_ba</a>.  <a href="vallist_8h.html#af4a72c65d3b93039ff475fa8ccfdefac">More...</a><br /></td></tr>
<tr class="separator:af4a72c65d3b93039ff475fa8ccfdefac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff65f7d8b22e407c0155027fbb667a08"><td class="memTemplParams" colspan="2">template&lt;class Seq , class Manip &gt; </td></tr>
<tr class="memitem:aff65f7d8b22e407c0155027fbb667a08"><td class="memTemplItemLeft" align="right" valign="top">value_list_ba&lt; Seq, Manip &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vallist_8h.html#aff65f7d8b22e407c0155027fbb667a08">mysqlpp::value_list</a> (const Seq &amp;s, const char *d, Manip m)</td></tr>
<tr class="memdesc:aff65f7d8b22e407c0155027fbb667a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="structmysqlpp_1_1value__list__ba.html" title="Holds a list of items, typically used to construct a SQL &quot;value list&quot;.">value_list_ba</a>.  <a href="vallist_8h.html#aff65f7d8b22e407c0155027fbb667a08">More...</a><br /></td></tr>
<tr class="separator:aff65f7d8b22e407c0155027fbb667a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74121e3b9914a429855ad6d0e70c2172"><td class="memTemplParams" colspan="2">template&lt;class Seq , class Manip &gt; </td></tr>
<tr class="memitem:a74121e3b9914a429855ad6d0e70c2172"><td class="memTemplItemLeft" align="right" valign="top">value_list_b&lt; Seq, Manip &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vallist_8h.html#a74121e3b9914a429855ad6d0e70c2172">mysqlpp::value_list</a> (const Seq &amp;s, const char *d, Manip m, const std::vector&lt; bool &gt; &amp;vb)</td></tr>
<tr class="memdesc:a74121e3b9914a429855ad6d0e70c2172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="structmysqlpp_1_1value__list__b.html" title="Same as value_list_ba, plus the option to have some elements of the list suppressed.">value_list_b</a> (sparse value list)  <a href="vallist_8h.html#a74121e3b9914a429855ad6d0e70c2172">More...</a><br /></td></tr>
<tr class="separator:a74121e3b9914a429855ad6d0e70c2172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2813894f74517f80ad2f66ff36be897b"><td class="memTemplParams" colspan="2">template&lt;class Seq , class Manip &gt; </td></tr>
<tr class="memitem:a2813894f74517f80ad2f66ff36be897b"><td class="memTemplItemLeft" align="right" valign="top">value_list_b&lt; Seq, Manip &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vallist_8h.html#a2813894f74517f80ad2f66ff36be897b">mysqlpp::value_list</a> (const Seq &amp;s, const char *d, Manip m, bool t0, bool t1=false, bool t2=false, bool t3=false, bool t4=false, bool t5=false, bool t6=false, bool t7=false, bool t8=false, bool t9=false, bool ta=false, bool tb=false, bool tc=false)</td></tr>
<tr class="memdesc:a2813894f74517f80ad2f66ff36be897b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="structmysqlpp_1_1value__list__b.html" title="Same as value_list_ba, plus the option to have some elements of the list suppressed.">value_list_b</a> (sparse value list)  <a href="vallist_8h.html#a2813894f74517f80ad2f66ff36be897b">More...</a><br /></td></tr>
<tr class="separator:a2813894f74517f80ad2f66ff36be897b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4490f602c7b8b06e3fe5f17e43171ded"><td class="memTemplParams" colspan="2">template&lt;class Seq &gt; </td></tr>
<tr class="memitem:a4490f602c7b8b06e3fe5f17e43171ded"><td class="memTemplItemLeft" align="right" valign="top">value_list_b&lt; Seq, do_nothing_type0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vallist_8h.html#a4490f602c7b8b06e3fe5f17e43171ded">mysqlpp::value_list</a> (const Seq &amp;s, const char *d, bool t0, bool t1=false, bool t2=false, bool t3=false, bool t4=false, bool t5=false, bool t6=false, bool t7=false, bool t8=false, bool t9=false, bool ta=false, bool tb=false, bool tc=false)</td></tr>
<tr class="memdesc:a4490f602c7b8b06e3fe5f17e43171ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sparse value list.  <a href="vallist_8h.html#a4490f602c7b8b06e3fe5f17e43171ded">More...</a><br /></td></tr>
<tr class="separator:a4490f602c7b8b06e3fe5f17e43171ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788f18caa122c7a4e92f8fb795c31bfe"><td class="memTemplParams" colspan="2">template&lt;class Seq &gt; </td></tr>
<tr class="memitem:a788f18caa122c7a4e92f8fb795c31bfe"><td class="memTemplItemLeft" align="right" valign="top">value_list_b&lt; Seq, do_nothing_type0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vallist_8h.html#a788f18caa122c7a4e92f8fb795c31bfe">mysqlpp::value_list</a> (const Seq &amp;s, bool t0, bool t1=false, bool t2=false, bool t3=false, bool t4=false, bool t5=false, bool t6=false, bool t7=false, bool t8=false, bool t9=false, bool ta=false, bool tb=false, bool tc=false)</td></tr>
<tr class="memdesc:a788f18caa122c7a4e92f8fb795c31bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sparse value list.  <a href="vallist_8h.html#a788f18caa122c7a4e92f8fb795c31bfe">More...</a><br /></td></tr>
<tr class="separator:a788f18caa122c7a4e92f8fb795c31bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d668a9cbaf5a51c877c70b8305033e5"><td class="memTemplParams" colspan="2">template&lt;class Seq1 , class Seq2 &gt; </td></tr>
<tr class="memitem:a6d668a9cbaf5a51c877c70b8305033e5"><td class="memTemplItemLeft" align="right" valign="top">equal_list_ba&lt; Seq1, Seq2, do_nothing_type0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vallist_8h.html#a6d668a9cbaf5a51c877c70b8305033e5">mysqlpp::equal_list</a> (const Seq1 &amp;s1, const Seq2 &amp;s2, const char *d=&quot;,&quot;, const char *e=&quot; = &quot;)</td></tr>
<tr class="memdesc:a6d668a9cbaf5a51c877c70b8305033e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" href="structmysqlpp_1_1equal__list__ba.html" title="Holds two lists of items, typically used to construct a SQL &quot;equals clause&quot;.">equal_list_ba</a>.  <a href="vallist_8h.html#a6d668a9cbaf5a51c877c70b8305033e5">More...</a><br /></td></tr>
<tr class="separator:a6d668a9cbaf5a51c877c70b8305033e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa2b7c57b4d42e4587f4cd4172e8229"><td class="memTemplParams" colspan="2">template&lt;class Seq1 , class Seq2 , class Manip &gt; </td></tr>
<tr class="memitem:a1aa2b7c57b4d42e4587f4cd4172e8229"><td class="memTemplItemLeft" align="right" valign="top">equal_list_ba&lt; Seq1, Seq2, Manip &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vallist_8h.html#a1aa2b7c57b4d42e4587f4cd4172e8229">mysqlpp::equal_list</a> (const Seq1 &amp;s1, const Seq2 &amp;s2, const char *d, const char *e, Manip m)</td></tr>
<tr class="memdesc:a1aa2b7c57b4d42e4587f4cd4172e8229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" href="structmysqlpp_1_1equal__list__ba.html" title="Holds two lists of items, typically used to construct a SQL &quot;equals clause&quot;.">equal_list_ba</a>.  <a href="vallist_8h.html#a1aa2b7c57b4d42e4587f4cd4172e8229">More...</a><br /></td></tr>
<tr class="separator:a1aa2b7c57b4d42e4587f4cd4172e8229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec821d7f933c45a1496fd6c916d1a27f"><td class="memTemplParams" colspan="2">template&lt;class Seq1 , class Seq2 , class Manip &gt; </td></tr>
<tr class="memitem:aec821d7f933c45a1496fd6c916d1a27f"><td class="memTemplItemLeft" align="right" valign="top">equal_list_b&lt; Seq1, Seq2, Manip &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vallist_8h.html#aec821d7f933c45a1496fd6c916d1a27f">mysqlpp::equal_list</a> (const Seq1 &amp;s1, const Seq2 &amp;s2, const char *d, const char *e, Manip m, const std::vector&lt; bool &gt; &amp;vb)</td></tr>
<tr class="memdesc:aec821d7f933c45a1496fd6c916d1a27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="structmysqlpp_1_1equal__list__b.html" title="Same as equal_list_ba, plus the option to have some elements of the equals clause suppressed.">equal_list_b</a> (sparse equal list)  <a href="vallist_8h.html#aec821d7f933c45a1496fd6c916d1a27f">More...</a><br /></td></tr>
<tr class="separator:aec821d7f933c45a1496fd6c916d1a27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158ffc0201b5aabf20c7be69c230c8bc"><td class="memTemplParams" colspan="2">template&lt;class Seq1 , class Seq2 , class Manip &gt; </td></tr>
<tr class="memitem:a158ffc0201b5aabf20c7be69c230c8bc"><td class="memTemplItemLeft" align="right" valign="top">equal_list_b&lt; Seq1, Seq2, Manip &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vallist_8h.html#a158ffc0201b5aabf20c7be69c230c8bc">mysqlpp::equal_list</a> (const Seq1 &amp;s1, const Seq2 &amp;s2, const char *d, const char *e, Manip m, bool t0, bool t1=false, bool t2=false, bool t3=false, bool t4=false, bool t5=false, bool t6=false, bool t7=false, bool t8=false, bool t9=false, bool ta=false, bool tb=false, bool tc=false)</td></tr>
<tr class="memdesc:a158ffc0201b5aabf20c7be69c230c8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="structmysqlpp_1_1equal__list__b.html" title="Same as equal_list_ba, plus the option to have some elements of the equals clause suppressed.">equal_list_b</a> (sparse equal list)  <a href="vallist_8h.html#a158ffc0201b5aabf20c7be69c230c8bc">More...</a><br /></td></tr>
<tr class="separator:a158ffc0201b5aabf20c7be69c230c8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b3eac886712cf5caf5da2fd1b50280"><td class="memTemplParams" colspan="2">template&lt;class Seq1 , class Seq2 &gt; </td></tr>
<tr class="memitem:a91b3eac886712cf5caf5da2fd1b50280"><td class="memTemplItemLeft" align="right" valign="top">equal_list_b&lt; Seq1, Seq2, do_nothing_type0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vallist_8h.html#a91b3eac886712cf5caf5da2fd1b50280">mysqlpp::equal_list</a> (const Seq1 &amp;s1, const Seq2 &amp;s2, const char *d, const char *e, bool t0, bool t1=false, bool t2=false, bool t3=false, bool t4=false, bool t5=false, bool t6=false, bool t7=false, bool t8=false, bool t9=false, bool ta=false, bool tb=false, bool tc=false)</td></tr>
<tr class="memdesc:a91b3eac886712cf5caf5da2fd1b50280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="structmysqlpp_1_1equal__list__b.html" title="Same as equal_list_ba, plus the option to have some elements of the equals clause suppressed.">equal_list_b</a> (sparse equal list)  <a href="vallist_8h.html#a91b3eac886712cf5caf5da2fd1b50280">More...</a><br /></td></tr>
<tr class="separator:a91b3eac886712cf5caf5da2fd1b50280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690e19dc9016c200586543559a0236ce"><td class="memTemplParams" colspan="2">template&lt;class Seq1 , class Seq2 &gt; </td></tr>
<tr class="memitem:a690e19dc9016c200586543559a0236ce"><td class="memTemplItemLeft" align="right" valign="top">equal_list_b&lt; Seq1, Seq2, do_nothing_type0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vallist_8h.html#a690e19dc9016c200586543559a0236ce">mysqlpp::equal_list</a> (const Seq1 &amp;s1, const Seq2 &amp;s2, const char *d, bool t0, bool t1=false, bool t2=false, bool t3=false, bool t4=false, bool t5=false, bool t6=false, bool t7=false, bool t8=false, bool t9=false, bool ta=false, bool tb=false, bool tc=false)</td></tr>
<tr class="memdesc:a690e19dc9016c200586543559a0236ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="structmysqlpp_1_1equal__list__b.html" title="Same as equal_list_ba, plus the option to have some elements of the equals clause suppressed.">equal_list_b</a> (sparse equal list)  <a href="vallist_8h.html#a690e19dc9016c200586543559a0236ce">More...</a><br /></td></tr>
<tr class="separator:a690e19dc9016c200586543559a0236ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab118db64ba8109b183aca1ef5af12964"><td class="memTemplParams" colspan="2">template&lt;class Seq1 , class Seq2 &gt; </td></tr>
<tr class="memitem:ab118db64ba8109b183aca1ef5af12964"><td class="memTemplItemLeft" align="right" valign="top">equal_list_b&lt; Seq1, Seq2, do_nothing_type0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vallist_8h.html#ab118db64ba8109b183aca1ef5af12964">mysqlpp::equal_list</a> (const Seq1 &amp;s1, const Seq2 &amp;s2, bool t0, bool t1=false, bool t2=false, bool t3=false, bool t4=false, bool t5=false, bool t6=false, bool t7=false, bool t8=false, bool t9=false, bool ta=false, bool tb=false, bool tc=false)</td></tr>
<tr class="memdesc:ab118db64ba8109b183aca1ef5af12964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="structmysqlpp_1_1equal__list__b.html" title="Same as equal_list_ba, plus the option to have some elements of the equals clause suppressed.">equal_list_b</a> (sparse equal list)  <a href="vallist_8h.html#ab118db64ba8109b183aca1ef5af12964">More...</a><br /></td></tr>
<tr class="separator:ab118db64ba8109b183aca1ef5af12964"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Declares templates for holding lists of values. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a7c8a0af0d14a6d66b2dd8faca38808fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8a0af0d14a6d66b2dd8faca38808fb">&#9670;&nbsp;</a></span>create_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::create_vector </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a vector of bool using a list of named fields. </p>
<p>This function is used with the ResUse and Result containers, which have a field_num() member function that maps a field name to its position number. So for each named field, we set the bool in the vector at the corresponding position to true.</p>
<p>This function is used within the library to build the vector used in calling the vector form of <a class="el" href="vallist_8h.html#ab118db64ba8109b183aca1ef5af12964" title="Constructs a equal_list_b (sparse equal list)">Row::equal_list()</a>, <a class="el" href="vallist_8h.html#a788f18caa122c7a4e92f8fb795c31bfe" title="Constructs a sparse value list.">Row::value_list()</a>, and Row::field_list(). See the "Harnessing SSQLS Internals" section of the user manual to see that feature at work. </p>

</div>
</div>
<a id="af99971e8fc60ea71827e96dedee6f12c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af99971e8fc60ea71827e96dedee6f12c">&#9670;&nbsp;</a></span>create_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::create_vector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t1</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t2</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t3</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t4</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t5</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t6</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t7</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t8</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t9</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ta</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tb</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a vector of bool with the given arguments as values. </p>
<p>This function takes up to 13 bools, with the size parameter controlling the actual number of parameters we pay attention to.</p>
<p>This function is used within the library to build the vector used in calling the vector form of <a class="el" href="vallist_8h.html#ab118db64ba8109b183aca1ef5af12964" title="Constructs a equal_list_b (sparse equal list)">Row::equal_list()</a>, <a class="el" href="vallist_8h.html#a788f18caa122c7a4e92f8fb795c31bfe" title="Constructs a sparse value list.">Row::value_list()</a>, and Row::field_list(). See the "Harnessing SSQLS Internals" section of the user manual to see that feature at work. </p>

</div>
</div>
<a id="ab118db64ba8109b183aca1ef5af12964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab118db64ba8109b183aca1ef5af12964">&#9670;&nbsp;</a></span>equal_list() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Seq1 , class Seq2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">equal_list_b&lt;Seq1, Seq2, do_nothing_type0&gt; mysqlpp::equal_list </td>
          <td>(</td>
          <td class="paramtype">const Seq1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Seq2 &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t1</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t2</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t3</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t4</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t5</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t6</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t7</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t8</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t9</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ta</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tb</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a equal_list_b (sparse equal list) </p>
<p>Same as equal_list(Seq&amp;, Seq&amp;, const char*, bool, bool...) except that it doesn't take the const char* argument. It uses a comma for the delimiter. This form is useful for building simple equals lists, where no manipulators are necessary, and the default delimiter and equals symbol are suitable. </p>

<p class="reference">References <a class="el" href="manip_8h.html#acabd5572224baf2f7c26f89bc082673fae465f6c0ca597e0ab6332883b7b5f00d">mysqlpp::do_nothing</a>, and <a class="el" href="vallist_8h.html#a6d668a9cbaf5a51c877c70b8305033e5">mysqlpp::equal_list()</a>.</p>

</div>
</div>
<a id="a690e19dc9016c200586543559a0236ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690e19dc9016c200586543559a0236ce">&#9670;&nbsp;</a></span>equal_list() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Seq1 , class Seq2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">equal_list_b&lt;Seq1, Seq2, do_nothing_type0&gt; mysqlpp::equal_list </td>
          <td>(</td>
          <td class="paramtype">const Seq1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Seq2 &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t1</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t2</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t3</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t4</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t5</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t6</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t7</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t8</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t9</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ta</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tb</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a equal_list_b (sparse equal list) </p>
<p>Same as equal_list(Seq&amp;, Seq&amp;, const char*, const char*, bool, bool...) except that it doesn't take the second const char* argument. It uses " = " for the equals symbol. </p>

<p class="reference">References <a class="el" href="manip_8h.html#acabd5572224baf2f7c26f89bc082673fae465f6c0ca597e0ab6332883b7b5f00d">mysqlpp::do_nothing</a>, and <a class="el" href="vallist_8h.html#a6d668a9cbaf5a51c877c70b8305033e5">mysqlpp::equal_list()</a>.</p>

</div>
</div>
<a id="a91b3eac886712cf5caf5da2fd1b50280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b3eac886712cf5caf5da2fd1b50280">&#9670;&nbsp;</a></span>equal_list() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Seq1 , class Seq2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">equal_list_b&lt;Seq1, Seq2, do_nothing_type0&gt; mysqlpp::equal_list </td>
          <td>(</td>
          <td class="paramtype">const Seq1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Seq2 &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t1</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t2</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t3</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t4</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t5</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t6</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t7</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t8</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t9</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ta</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tb</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a equal_list_b (sparse equal list) </p>
<p>Same as equal_list(Seq&amp;, Seq&amp;, const char*, const char*, Manip, bool, bool...) except that it doesn't take the Manip argument. It uses the do_nothing manipulator instead, meaning that none of the elements are escaped when being inserted into a stream. </p>

<p class="reference">References <a class="el" href="manip_8h.html#acabd5572224baf2f7c26f89bc082673fae465f6c0ca597e0ab6332883b7b5f00d">mysqlpp::do_nothing</a>, and <a class="el" href="vallist_8h.html#a6d668a9cbaf5a51c877c70b8305033e5">mysqlpp::equal_list()</a>.</p>

</div>
</div>
<a id="a1aa2b7c57b4d42e4587f4cd4172e8229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa2b7c57b4d42e4587f4cd4172e8229">&#9670;&nbsp;</a></span>equal_list() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Seq1 , class Seq2 , class Manip &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">equal_list_ba&lt;Seq1, Seq2, Manip&gt; mysqlpp::equal_list </td>
          <td>(</td>
          <td class="paramtype">const Seq1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Seq2 &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Manip&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an equal_list_ba. </p>
<p>Same as equal_list(Seq&amp;, Seq&amp;, const char*, const char*) except that it also lets you specify the manipulator. Use this version if the data must be escaped or quoted when being inserted into a stream. </p>

<p class="reference">References <a class="el" href="vallist_8h.html#a6d668a9cbaf5a51c877c70b8305033e5">mysqlpp::equal_list()</a>.</p>

</div>
</div>
<a id="a158ffc0201b5aabf20c7be69c230c8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158ffc0201b5aabf20c7be69c230c8bc">&#9670;&nbsp;</a></span>equal_list() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Seq1 , class Seq2 , class Manip &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">equal_list_b&lt;Seq1, Seq2, Manip&gt; mysqlpp::equal_list </td>
          <td>(</td>
          <td class="paramtype">const Seq1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Seq2 &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Manip&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t1</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t2</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t3</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t4</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t5</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t6</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t7</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t8</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t9</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ta</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tb</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a equal_list_b (sparse equal list) </p>
<p>Same as equal_list(Seq&amp;, Seq&amp;, const char*, const char*, Manip, vector&lt;bool&gt;&amp;) except that it takes boolean parameters instead of a list of bools. </p>

<p class="reference">References <a class="el" href="vallist_8h.html#a6d668a9cbaf5a51c877c70b8305033e5">mysqlpp::equal_list()</a>.</p>

</div>
</div>
<a id="aec821d7f933c45a1496fd6c916d1a27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec821d7f933c45a1496fd6c916d1a27f">&#9670;&nbsp;</a></span>equal_list() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Seq1 , class Seq2 , class Manip &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">equal_list_b&lt;Seq1, Seq2, Manip&gt; mysqlpp::equal_list </td>
          <td>(</td>
          <td class="paramtype">const Seq1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Seq2 &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Manip&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>vb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a equal_list_b (sparse equal list) </p>
<p>Same as equal_list(Seq&amp;, Seq&amp;, const char*, const char*, Manip) except that you can pass a vector of bools. For each true item in that list, operator&lt;&lt; adds the corresponding item is put in the equal list. This lets you pass in sequences when you don't want all of the elements to be inserted into a stream. </p>

<p class="reference">References <a class="el" href="vallist_8h.html#a6d668a9cbaf5a51c877c70b8305033e5">mysqlpp::equal_list()</a>.</p>

</div>
</div>
<a id="a6d668a9cbaf5a51c877c70b8305033e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d668a9cbaf5a51c877c70b8305033e5">&#9670;&nbsp;</a></span>equal_list() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Seq1 , class Seq2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">equal_list_ba&lt;Seq1, Seq2, do_nothing_type0&gt; mysqlpp::equal_list </td>
          <td>(</td>
          <td class="paramtype">const Seq1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Seq2 &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>d</em> = <code>&quot;,&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>e</em> = <code>&quot;&#160;=&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an equal_list_ba. </p>
<p>This function returns an equal list that uses the 'do_nothing' manipulator. That is, the items are not quoted or escaped in any way when inserted into a stream. See equal_list(Seq, Seq, const char*, const char*, Manip) if you need a different manipulator.</p>
<p>The idea is for both lists to be of equal length because corresponding elements from each list are handled as pairs, but if one list is shorter than the other, the generated list will have that many elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>items on the left side of the equals sign when the equal list is inserted into a stream </td></tr>
    <tr><td class="paramname">s2</td><td>items on the right side of the equals sign </td></tr>
    <tr><td class="paramname">d</td><td>delimiter operator&lt;&lt; should place between pairs </td></tr>
    <tr><td class="paramname">e</td><td>what operator&lt;&lt; should place between items in each pair; by default, an equals sign, as that is the primary use for this mechanism. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="manip_8h.html#acabd5572224baf2f7c26f89bc082673fae465f6c0ca597e0ab6332883b7b5f00d">mysqlpp::do_nothing</a>, and <a class="el" href="vallist_8h.html#a6d668a9cbaf5a51c877c70b8305033e5">mysqlpp::equal_list()</a>.</p>

<p class="reference">Referenced by <a class="el" href="vallist_8h.html#a6d668a9cbaf5a51c877c70b8305033e5">mysqlpp::equal_list()</a>.</p>

</div>
</div>
<a id="a3fa2009cde5ff7ee5d817d9e8e1b9ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa2009cde5ff7ee5d817d9e8e1b9ace">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Seq1 , class Seq2 , class Manip &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; mysqlpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a>&lt; Seq1, Seq2, Manip &gt; &amp;&#160;</td>
          <td class="paramname"><em>el</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as operator&lt;&lt; for equal_list_ba, plus the option to suppress insertion of some list items in the stream. </p>
<p>See equal_list_b's documentation for examples of how this works. </p>

<p class="reference">References <a class="el" href="structmysqlpp_1_1equal__list__b.html#acc88d6a3d51f9e985641f3931a026c59">mysqlpp::equal_list_b&lt; Seq1, Seq2, Manip &gt;::delim</a>, <a class="el" href="structmysqlpp_1_1equal__list__b.html#a5092f431c71217200400c94eed206f6e">mysqlpp::equal_list_b&lt; Seq1, Seq2, Manip &gt;::equl</a>, <a class="el" href="structmysqlpp_1_1equal__list__b.html#a4b47050126de3e1afbc99cba2f4f37b6">mysqlpp::equal_list_b&lt; Seq1, Seq2, Manip &gt;::fields</a>, <a class="el" href="structmysqlpp_1_1equal__list__b.html#a7b24538643ef04ca3969f4597a2e9337">mysqlpp::equal_list_b&lt; Seq1, Seq2, Manip &gt;::list1</a>, <a class="el" href="structmysqlpp_1_1equal__list__b.html#ace8b74187f066eba8ad90b46be681f6b">mysqlpp::equal_list_b&lt; Seq1, Seq2, Manip &gt;::list2</a>, and <a class="el" href="structmysqlpp_1_1equal__list__b.html#a0519c5d83b6ded32b258ff58d1972e38">mysqlpp::equal_list_b&lt; Seq1, Seq2, Manip &gt;::manip</a>.</p>

</div>
</div>
<a id="a14959a9a7adf3bdb1f68ab7ea4e6bb7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14959a9a7adf3bdb1f68ab7ea4e6bb7e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Seq1 , class Seq2 , class Manip &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; mysqlpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmysqlpp_1_1equal__list__ba.html">equal_list_ba</a>&lt; Seq1, Seq2, Manip &gt; &amp;&#160;</td>
          <td class="paramname"><em>el</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts an equal_list_ba into an std::ostream. </p>
<p>Given two lists (a, b) and (c, d), a delimiter D, and an equals symbol E, this operator will insert "aEcDbEd" into the stream.</p>
<p>See equal_list_ba's documentation for concrete examples.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="vallist_8h.html#ab118db64ba8109b183aca1ef5af12964" title="Constructs a equal_list_b (sparse equal list)">equal_list()</a> </dd></dl>

<p class="reference">References <a class="el" href="structmysqlpp_1_1equal__list__ba.html#a11cce071cfe6c26585602970e0eab481">mysqlpp::equal_list_ba&lt; Seq1, Seq2, Manip &gt;::delim</a>, <a class="el" href="structmysqlpp_1_1equal__list__ba.html#a5f8c1b857897e584bd78c1a9f58439a7">mysqlpp::equal_list_ba&lt; Seq1, Seq2, Manip &gt;::equl</a>, <a class="el" href="structmysqlpp_1_1equal__list__ba.html#af0307d8b613d4ea52c0d9eb19b462e12">mysqlpp::equal_list_ba&lt; Seq1, Seq2, Manip &gt;::list1</a>, <a class="el" href="structmysqlpp_1_1equal__list__ba.html#a50b12dedeeba529383fd2ac61a566599">mysqlpp::equal_list_ba&lt; Seq1, Seq2, Manip &gt;::list2</a>, and <a class="el" href="structmysqlpp_1_1equal__list__ba.html#ae80eca8a48261205c78b7f73f1aa8f17">mysqlpp::equal_list_ba&lt; Seq1, Seq2, Manip &gt;::manip</a>.</p>

</div>
</div>
<a id="ae42f3fce3eb51f9257d519728ebb247c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae42f3fce3eb51f9257d519728ebb247c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Seq , class Manip &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; mysqlpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmysqlpp_1_1value__list__b.html">value_list_b</a>&lt; Seq, Manip &gt; &amp;&#160;</td>
          <td class="paramname"><em>cl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as operator&lt;&lt; for value_list_ba, plus the option to suppress insertion of some list items in the stream. </p>
<p>See value_list_b's documentation for examples of how this works. </p>

<p class="reference">References <a class="el" href="structmysqlpp_1_1value__list__b.html#acad7cd0a818d772b907502956da4dd9a">mysqlpp::value_list_b&lt; Seq, Manip &gt;::delim</a>, <a class="el" href="structmysqlpp_1_1value__list__b.html#ae4db426c6a7d661f5a94d9dc4b1acce7">mysqlpp::value_list_b&lt; Seq, Manip &gt;::fields</a>, <a class="el" href="structmysqlpp_1_1value__list__b.html#a2b804fe2d3c181d8ec2a2db4737fe2de">mysqlpp::value_list_b&lt; Seq, Manip &gt;::list</a>, and <a class="el" href="structmysqlpp_1_1value__list__b.html#af40a0443dfc363c76fa2201ea0bc352c">mysqlpp::value_list_b&lt; Seq, Manip &gt;::manip</a>.</p>

</div>
</div>
<a id="a5190aab5cca65dbb641e287de9cb6f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5190aab5cca65dbb641e287de9cb6f66">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Seq , class Manip &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; mysqlpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmysqlpp_1_1value__list__ba.html">value_list_ba</a>&lt; Seq, Manip &gt; &amp;&#160;</td>
          <td class="paramname"><em>cl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a value_list_ba into an std::ostream. </p>
<p>Given a list (a, b) and a delimiter D, this operator will insert "aDb" into the stream.</p>
<p>See value_list_ba's documentation for concrete examples.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="vallist_8h.html#a788f18caa122c7a4e92f8fb795c31bfe" title="Constructs a sparse value list.">value_list()</a> </dd></dl>

<p class="reference">References <a class="el" href="structmysqlpp_1_1value__list__ba.html#a6b0f93524912bc3a861b5764883287b7">mysqlpp::value_list_ba&lt; Seq, Manip &gt;::delim</a>, <a class="el" href="structmysqlpp_1_1value__list__ba.html#abab3903454b75548f120269967696c26">mysqlpp::value_list_ba&lt; Seq, Manip &gt;::list</a>, and <a class="el" href="structmysqlpp_1_1value__list__ba.html#a88e7f44bdf891147b949faa780a7948b">mysqlpp::value_list_ba&lt; Seq, Manip &gt;::manip</a>.</p>

</div>
</div>
<a id="a788f18caa122c7a4e92f8fb795c31bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788f18caa122c7a4e92f8fb795c31bfe">&#9670;&nbsp;</a></span>value_list() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Seq &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">value_list_b&lt;Seq, do_nothing_type0&gt; mysqlpp::value_list </td>
          <td>(</td>
          <td class="paramtype">const Seq &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t1</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t2</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t3</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t4</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t5</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t6</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t7</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t8</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t9</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ta</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tb</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a sparse value list. </p>
<p>Same as value_list(Seq&amp;, const char*, Manip, bool, bool...) but without the Manip or delimiter parameters. We use the do_nothing manipulator, meaning that the value list items are neither escaped nor quoted when being inserted into a stream. The delimiter is a comma. This form is suitable for lists of simple data, such as integers. </p>

<p class="reference">References <a class="el" href="manip_8h.html#acabd5572224baf2f7c26f89bc082673fae465f6c0ca597e0ab6332883b7b5f00d">mysqlpp::do_nothing</a>, and <a class="el" href="vallist_8h.html#af4a72c65d3b93039ff475fa8ccfdefac">mysqlpp::value_list()</a>.</p>

</div>
</div>
<a id="a4490f602c7b8b06e3fe5f17e43171ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4490f602c7b8b06e3fe5f17e43171ded">&#9670;&nbsp;</a></span>value_list() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Seq &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">value_list_b&lt;Seq, do_nothing_type0&gt; mysqlpp::value_list </td>
          <td>(</td>
          <td class="paramtype">const Seq &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t1</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t2</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t3</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t4</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t5</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t6</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t7</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t8</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t9</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ta</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tb</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a sparse value list. </p>
<p>Same as value_list(Seq&amp;, const char*, Manip, bool, bool...) but without the Manip parameter. We use the do_nothing manipulator, meaning that the value list items are neither escaped nor quoted when being inserted into a stream. </p>

<p class="reference">References <a class="el" href="manip_8h.html#acabd5572224baf2f7c26f89bc082673fae465f6c0ca597e0ab6332883b7b5f00d">mysqlpp::do_nothing</a>, and <a class="el" href="vallist_8h.html#af4a72c65d3b93039ff475fa8ccfdefac">mysqlpp::value_list()</a>.</p>

</div>
</div>
<a id="aff65f7d8b22e407c0155027fbb667a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff65f7d8b22e407c0155027fbb667a08">&#9670;&nbsp;</a></span>value_list() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Seq , class Manip &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">value_list_ba&lt;Seq, Manip&gt; mysqlpp::value_list </td>
          <td>(</td>
          <td class="paramtype">const Seq &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Manip&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a value_list_ba. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>an STL sequence of items in the value list </td></tr>
    <tr><td class="paramname">d</td><td>delimiter operator&lt;&lt; should place between items </td></tr>
    <tr><td class="paramname">m</td><td>manipulator to use when inserting items into a stream </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="vallist_8h.html#af4a72c65d3b93039ff475fa8ccfdefac">mysqlpp::value_list()</a>.</p>

</div>
</div>
<a id="a2813894f74517f80ad2f66ff36be897b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2813894f74517f80ad2f66ff36be897b">&#9670;&nbsp;</a></span>value_list() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Seq , class Manip &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">value_list_b&lt;Seq, Manip&gt; mysqlpp::value_list </td>
          <td>(</td>
          <td class="paramtype">const Seq &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Manip&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t1</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t2</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t3</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t4</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t5</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t6</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t7</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t8</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t9</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ta</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tb</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a value_list_b (sparse value list) </p>
<p>Same as value_list(Seq&amp;, const char*, Manip, const vector&lt;bool&gt;&amp;), except that it takes the bools as arguments instead of wrapped up in a vector object. </p>

<p class="reference">References <a class="el" href="vallist_8h.html#af4a72c65d3b93039ff475fa8ccfdefac">mysqlpp::value_list()</a>.</p>

</div>
</div>
<a id="a74121e3b9914a429855ad6d0e70c2172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74121e3b9914a429855ad6d0e70c2172">&#9670;&nbsp;</a></span>value_list() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Seq , class Manip &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_list_b&lt;Seq, Manip&gt; mysqlpp::value_list </td>
          <td>(</td>
          <td class="paramtype">const Seq &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Manip&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>vb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a value_list_b (sparse value list) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>an STL sequence of items in the value list </td></tr>
    <tr><td class="paramname">d</td><td>delimiter operator&lt;&lt; should place between items </td></tr>
    <tr><td class="paramname">m</td><td>manipulator to use when inserting items into a stream </td></tr>
    <tr><td class="paramname">vb</td><td>for each item in this vector that is true, the corresponding item in the value list is inserted into a stream; the others are suppressed </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="vallist_8h.html#af4a72c65d3b93039ff475fa8ccfdefac">mysqlpp::value_list()</a>.</p>

</div>
</div>
<a id="af4a72c65d3b93039ff475fa8ccfdefac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a72c65d3b93039ff475fa8ccfdefac">&#9670;&nbsp;</a></span>value_list() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Seq &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">value_list_ba&lt;Seq, do_nothing_type0&gt; mysqlpp::value_list </td>
          <td>(</td>
          <td class="paramtype">const Seq &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>d</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a value_list_ba. </p>
<p>This function returns a value list that uses the 'do_nothing' manipulator. That is, the items are not quoted or escaped in any way. See value_list(Seq, const char*, Manip) if you need to specify a manipulator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>an STL sequence of items in the value list </td></tr>
    <tr><td class="paramname">d</td><td>delimiter operator&lt;&lt; should place between items </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="manip_8h.html#acabd5572224baf2f7c26f89bc082673fae465f6c0ca597e0ab6332883b7b5f00d">mysqlpp::do_nothing</a>, and <a class="el" href="vallist_8h.html#af4a72c65d3b93039ff475fa8ccfdefac">mysqlpp::value_list()</a>.</p>

<p class="reference">Referenced by <a class="el" href="vallist_8h.html#af4a72c65d3b93039ff475fa8ccfdefac">mysqlpp::value_list()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 28 2021 16:40:15 for MySQL++ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
